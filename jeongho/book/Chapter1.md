# 1장

#### 1. MSA의 궁극적인 목적은 무엇인가?
- 기존의 모노폴리틱 아키텍쳐는 기능이 늘어날수록 용량도 커지고 유지보수가 점점 힘들어짐.
- 빠른 개발, 지속적 배포, 쉬운 유지보수

#### 2. 로드밸런싱 vs 리버스 프록시
- 로드밸런싱은 말 그대로 여러 서버에 부하를 분산시킴
- 리버스 프록시는 클라이언트에서 서버 접근 요청이 오면 각각의 서버(endpoint)로 연결해줌. (ex. nginX)
- 참조(https://jay-ji.tistory.com/50)

#### 3. 그래서 에지서버는?
- 일부의 마이크로 서비스 접근만 허용하기위해 리버스 프록시로 클라이언트 요청을 받음
- 로드밸런싱 기능을 제공하기도함

#### 4. Sync vs Async vs Blocking vs Nonblocking
- Blocking : 앱 실행시 운영체제 대기 큐에 들어가며 요청에대한 시스템콜이 완료된 후에 응답
- Nonblocking : 앱 실행시 운영체제 대기 큐에 들어가지 않고 실행 여부와 관계없이 바로 응답
- Sync : 시스템콜을 기다림, 대기 큐에 머무는것이 필수가 아님
- Async : 시스템콜을 기다리지 않는다 

- Sync + Blocking : 커널과 한번의 context-switching이 일어남, 커널의 일을 기다리느라 블록되어있음
- Sync + Nonblocking : 위 방식의 개선안이지만 계속 context-switching을 해서 I/O latency초래
- Async + Blocking : select() 시스템함수 호출이 사용자프로세스를 블로킹함, 비효율적임
- Async + Nonblocking : IO 응답이 도착하면 신호나 콜백으로 IO전달을 완료

-참조(https://sjh836.tistory.com/109)

#### 5. 중앙화
- 구성 중앙화 : 여러 인스턴스의 구성 정보를 한눈에 보기위해 환경 변수나 여러 정보를 하나의 컴포넌트로 관리함
- 로그 중앙화 : 각 인스턴스의 로그 기록을 중앙에서 관리, 추적을 위해 모든 수신 요청과 이벤트에 상관ID부여

